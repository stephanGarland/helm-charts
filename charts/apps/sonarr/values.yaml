generic-app:
  # nameOverride -- name of the chart/release to override 'generic-app' with
  nameOverride: sonarr

  ##
  # Pods configuration
  ##

  pods:
    # pods.controller -- controller used to schedule pods
    # Can either be 'deployment', 'statefulset' or 'daemonset'
    controller: statefulset

    # Container image to use
    image:
      # pods.image.name -- image repository/name
      name: linuxserver/sonarr

      # pods.image.tag -- image tag
      tag: 3.0.10

      # pods.image.pullPolicy -- image pullPolicy
      pullPolicy: IfNotPresent

      # pods.image.pullSecrets -- Optional array of imagePullSecrets containing private registry credentials
      # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
      pullSecrets: []
      # - name: secretName

      # pods.image.pullCredentials -- Automatically create a secret with the credentials and use it
      # Cannot be used in conjunction of image.pullSecrets
      pullCredentials: {}
        # registry: quay.io
        # username: someone
        # password: sillyness

    # pods.replicas -- amount of desired pod(s) replica(s)
    # Ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#replicas
    replicas: 1

    # Specify revisionHistoryLimit (deployments only)
    # Ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#clean-up-policy
    revisionHistoryLimit: 2

    # The update strategy to apply for the deployment, statefulset or daemonset
    ##
    updateStrategy: {}
    #  rollingUpdate:
    #    maxUnavailable: 1
    #  type: RollingUpdate

    # Custom command to use for the container
    command: []

    # Custom arguments to use for the container
    args: []

    # Additional labels and annotations for the deployment, statefulset or daemonset
    labels:
    #  key: value
    annotations: {}
    #  key: value

    # Additional labels and annotations for the pods
    podLabels: {}
    #  key: value
    podAnnotations: {}
    #  key: value

    # Healthcheck probes
    livenessProbe:
      httpGet:
        path: /
        port: 443
      initialDelaySeconds: 10
    readinessProbe: {}

    # Resources allocation for the containers
    resources:
      limits:
        memory: 2Gi
      requests:
        cpu: 1000m
        memory: 1Gi

    ports:
      - containerPort: 8989

    # Node labels for pod assignment
    # Ref: https://kubernetes.io/docs/user-guide/node-selection/
    nodeSelector: {}

    ## Node tolerations for server scheduling to nodes with taints
    ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
    ##
    tolerations: []
    #  - key: "key"
    #    operator: "Equal|Exists"
    #    value: "value"
    #    effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"

    # DNS Policy - defaults to ClusterFirst
    # dnsPolicy: ClusterFirst

    # Affinity configuration
    affinity:
      # This allows you to automatically define anti-affinity rules
      antiAffinity:
        enabled: false
        type: hard  # Can be either 'hard' or 'soft'
        topologyKey: kubernetes.io/hostname

    # Environment variables
    env: []
      # - name: key
      #   value: val
      # - name: other_key
      #    valueFrom:
      #      configMapKeyRef:
      #        name: config
      #        key: nice-key

    envFrom:
      - configMapRef:
         name: sonarr-cm
      # - secretRef:
      #     name: config

    # Volumes and mounts
    volumes:
      - name: "sonarr-tv"
        nfs:
          path: "/export/tv"
          server: "192.168.1.202"
      # - name: storage
      #   emptyDir: {}

    volumeMounts:
      - name: "sonarr-config"
        mountPath: "/config"
      - name: "sonarr-tv"
        mountPath: "/tv"
      # - name: storage
      #   mountPath: /mnt/storage

    volumeClaimTemplates:
      # Defaults to app.fullname-config
      # nameOverride: ""
      # Defaults to ReadWriteOnce
      # accessModes: [ "ReadWriteMany" ]
      storageClassName: "longhorn-retain"
      # Defaults to 1Gi
      # storageSize: "2Gi"
    # Security
    securityContext: {}

    # Init containers configuration
    initContainers: []

    # Additional containers for the pods
    additionalContainers: []

  ##
  # Image Pull Credentials
  ##

  # Automatically create a secret with the credentials and use it
  # Cannot be used in conjunction of pods.imagePullSecrets
  imageCredentials: {}
    # registry: quay.io
    # username: someone
    # password: sillyness

  ##
  # Horizontal Pod Autoscaler configuration
  ##

  # Only works for 'deployments' and 'statefulsets'
  horizontalPodAutoscaler:
    enabled: false
    minReplicas: 1
    maxReplicas: 2
    targetAverageCPUUtilization: 60

  ##
  # Service configuration
  ##

  service:
    enabled: true
    ports:
      - port: 80
        targetPort: 8989
        protocol: TCP
        name: http
    # Defaults to LoadBalancer
    # type: ClusterIP
    # Does not have a default value
    loadBalancerClass: tailscale

  ##
  # Ingress configuration
  ##

  ingress:
    enabled: false
    annotations:
      kubernetes.io/ingress.class: nginx
      nginx.ingress.kubernetes.io/force-ssl-redirect: "true"

    path: /
    pathType: Prefix

    ingressClassName: ""

    service:
      port:
        name: http

    hosts: []
      # - example.com
    tls: []
      # - hosts:
      #     - example.com

  ##
  # Pod Disruption Budget configuration
  ##

  podDisruptionBudget:
    enabled: true
    minAvailable: 1

  ##
  # ConfigMaps management
  ##

  configMaps:
    cm:
      PGID: "1000"
      PUID: "1000"
      TZ: "America/Chicago"
      UMASK: "002"
    # foo:
    #   FOO: bar

  ##
  # Secrets management
  ##

  secrets: {}
    # super_secret:
    #   key: sensitive_value
    # dockerconfigjson/image-pull: |
    #   .dockerconfigjson: {}

  ##
  # Service account management
  ##

  serviceAccount:
    # serviceAccount.create -- create a service account and associate it with the pods
    create: false

    # serviceAccount.name -- name of the service account to use (and potentially create)
    name: default

  ##
  # Service monitor configuration
  ##

  serviceMonitor:
    enabled: false
    interval: 30s
    port: metrics
    path: /metrics

  ##
  # Datadog specific env variables and labels
  ##

  datadog:
    # global.datadog.enabled -- inject datadog related labels/env variables
    enabled: false

    # global.datadog.env -- current environment
    # env: (default to unknown)

    # global.datadog.service -- app/service name
    # service: (default to release name)

    # global.datadog.version -- app version
    # version: (default to appVersion + release revision)

  ##
  # Global configuration (ideal when embedding this chart within another)
  ##

  global:
    ##
    # Datadog specific env variables and labels
    ##

    datadog:
      # global.datadog.enabled -- inject datadog related labels/env variables
      enabled: false

      # global.datadog.env -- current environment
      # env: (default to unknown)

      # global.datadog.service -- app/service name
      # service: (default to release name)

      # global.datadog.version -- app version
      # version: (default to appVersion + release revision)
